// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        (unknown)
// source: avf/v1/spec.proto

package avfv1

import (
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"

	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type TrackType int32

const (
	TrackType_TRACK_TYPE_UNSPECIFIED TrackType = 0
	TrackType_TRACK_TYPE_AUDIO       TrackType = 1
	TrackType_TRACK_TYPE_VIDEO       TrackType = 2
)

// Enum value maps for TrackType.
var (
	TrackType_name = map[int32]string{
		0: "TRACK_TYPE_UNSPECIFIED",
		1: "TRACK_TYPE_AUDIO",
		2: "TRACK_TYPE_VIDEO",
	}
	TrackType_value = map[string]int32{
		"TRACK_TYPE_UNSPECIFIED": 0,
		"TRACK_TYPE_AUDIO":       1,
		"TRACK_TYPE_VIDEO":       2,
	}
)

func (x TrackType) Enum() *TrackType {
	p := new(TrackType)
	*p = x
	return p
}

func (x TrackType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TrackType) Descriptor() protoreflect.EnumDescriptor {
	return file_avf_v1_spec_proto_enumTypes[0].Descriptor()
}

func (TrackType) Type() protoreflect.EnumType {
	return &file_avf_v1_spec_proto_enumTypes[0]
}

func (x TrackType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TrackType.Descriptor instead.
func (TrackType) EnumDescriptor() ([]byte, []int) {
	return file_avf_v1_spec_proto_rawDescGZIP(), []int{0}
}

type CodecType int32

const (
	CodecType_CODEC_TYPE_UNSPECIFIED CodecType = 0
	CodecType_CODEC_TYPE_CUSTOM      CodecType = 16
	CodecType_CODEC_TYPE_NONE        CodecType = 1
)

// Enum value maps for CodecType.
var (
	CodecType_name = map[int32]string{
		0:  "CODEC_TYPE_UNSPECIFIED",
		16: "CODEC_TYPE_CUSTOM",
		1:  "CODEC_TYPE_NONE",
	}
	CodecType_value = map[string]int32{
		"CODEC_TYPE_UNSPECIFIED": 0,
		"CODEC_TYPE_CUSTOM":      16,
		"CODEC_TYPE_NONE":        1,
	}
)

func (x CodecType) Enum() *CodecType {
	p := new(CodecType)
	*p = x
	return p
}

func (x CodecType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (CodecType) Descriptor() protoreflect.EnumDescriptor {
	return file_avf_v1_spec_proto_enumTypes[1].Descriptor()
}

func (CodecType) Type() protoreflect.EnumType {
	return &file_avf_v1_spec_proto_enumTypes[1]
}

func (x CodecType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use CodecType.Descriptor instead.
func (CodecType) EnumDescriptor() ([]byte, []int) {
	return file_avf_v1_spec_proto_rawDescGZIP(), []int{1}
}

type FormatType int32

const (
	FormatType_FORMAT_TYPE_UNSPECIFIED FormatType = 0
	FormatType_FORMAT_TYPE_CUSTOM      FormatType = 16
	FormatType_FORMAT_TYPE_RAW         FormatType = 1
)

// Enum value maps for FormatType.
var (
	FormatType_name = map[int32]string{
		0:  "FORMAT_TYPE_UNSPECIFIED",
		16: "FORMAT_TYPE_CUSTOM",
		1:  "FORMAT_TYPE_RAW",
	}
	FormatType_value = map[string]int32{
		"FORMAT_TYPE_UNSPECIFIED": 0,
		"FORMAT_TYPE_CUSTOM":      16,
		"FORMAT_TYPE_RAW":         1,
	}
)

func (x FormatType) Enum() *FormatType {
	p := new(FormatType)
	*p = x
	return p
}

func (x FormatType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (FormatType) Descriptor() protoreflect.EnumDescriptor {
	return file_avf_v1_spec_proto_enumTypes[2].Descriptor()
}

func (FormatType) Type() protoreflect.EnumType {
	return &file_avf_v1_spec_proto_enumTypes[2]
}

func (x FormatType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use FormatType.Descriptor instead.
func (FormatType) EnumDescriptor() ([]byte, []int) {
	return file_avf_v1_spec_proto_rawDescGZIP(), []int{2}
}

type TransformSpec struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Inputs        []*InputSpec           `protobuf:"bytes,1,rep,name=inputs,proto3" json:"inputs,omitempty"`
	Outputs       []*OutputSpec          `protobuf:"bytes,2,rep,name=outputs,proto3" json:"outputs,omitempty"`
	Pipeline      *PipelineSpec          `protobuf:"bytes,3,opt,name=pipeline,proto3" json:"pipeline,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TransformSpec) Reset() {
	*x = TransformSpec{}
	mi := &file_avf_v1_spec_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TransformSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TransformSpec) ProtoMessage() {}

func (x *TransformSpec) ProtoReflect() protoreflect.Message {
	mi := &file_avf_v1_spec_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TransformSpec.ProtoReflect.Descriptor instead.
func (*TransformSpec) Descriptor() ([]byte, []int) {
	return file_avf_v1_spec_proto_rawDescGZIP(), []int{0}
}

func (x *TransformSpec) GetInputs() []*InputSpec {
	if x != nil {
		return x.Inputs
	}
	return nil
}

func (x *TransformSpec) GetOutputs() []*OutputSpec {
	if x != nil {
		return x.Outputs
	}
	return nil
}

func (x *TransformSpec) GetPipeline() *PipelineSpec {
	if x != nil {
		return x.Pipeline
	}
	return nil
}

type PipelineSpec struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Nodes         []*NodeSpec            `protobuf:"bytes,1,rep,name=nodes,proto3" json:"nodes,omitempty"`
	Links         []*PortLinkSpec        `protobuf:"bytes,2,rep,name=links,proto3" json:"links,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PipelineSpec) Reset() {
	*x = PipelineSpec{}
	mi := &file_avf_v1_spec_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PipelineSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PipelineSpec) ProtoMessage() {}

func (x *PipelineSpec) ProtoReflect() protoreflect.Message {
	mi := &file_avf_v1_spec_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PipelineSpec.ProtoReflect.Descriptor instead.
func (*PipelineSpec) Descriptor() ([]byte, []int) {
	return file_avf_v1_spec_proto_rawDescGZIP(), []int{1}
}

func (x *PipelineSpec) GetNodes() []*NodeSpec {
	if x != nil {
		return x.Nodes
	}
	return nil
}

func (x *PipelineSpec) GetLinks() []*PortLinkSpec {
	if x != nil {
		return x.Links
	}
	return nil
}

type PortLinkSpec struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Source        string                 `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	SourcePort    int32                  `protobuf:"varint,2,opt,name=source_port,json=sourcePort,proto3" json:"source_port,omitempty"`
	Sink          string                 `protobuf:"bytes,3,opt,name=sink,proto3" json:"sink,omitempty"`
	SinkPort      int32                  `protobuf:"varint,4,opt,name=sink_port,json=sinkPort,proto3" json:"sink_port,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PortLinkSpec) Reset() {
	*x = PortLinkSpec{}
	mi := &file_avf_v1_spec_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PortLinkSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PortLinkSpec) ProtoMessage() {}

func (x *PortLinkSpec) ProtoReflect() protoreflect.Message {
	mi := &file_avf_v1_spec_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PortLinkSpec.ProtoReflect.Descriptor instead.
func (*PortLinkSpec) Descriptor() ([]byte, []int) {
	return file_avf_v1_spec_proto_rawDescGZIP(), []int{2}
}

func (x *PortLinkSpec) GetSource() string {
	if x != nil {
		return x.Source
	}
	return ""
}

func (x *PortLinkSpec) GetSourcePort() int32 {
	if x != nil {
		return x.SourcePort
	}
	return 0
}

func (x *PortLinkSpec) GetSink() string {
	if x != nil {
		return x.Sink
	}
	return ""
}

func (x *PortLinkSpec) GetSinkPort() int32 {
	if x != nil {
		return x.SinkPort
	}
	return 0
}

type NodeSpec struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Name  string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Types that are valid to be assigned to NodeType:
	//
	//	*NodeSpec_AvfilterGraph
	NodeType      isNodeSpec_NodeType `protobuf_oneof:"node_type"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodeSpec) Reset() {
	*x = NodeSpec{}
	mi := &file_avf_v1_spec_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeSpec) ProtoMessage() {}

func (x *NodeSpec) ProtoReflect() protoreflect.Message {
	mi := &file_avf_v1_spec_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeSpec.ProtoReflect.Descriptor instead.
func (*NodeSpec) Descriptor() ([]byte, []int) {
	return file_avf_v1_spec_proto_rawDescGZIP(), []int{3}
}

func (x *NodeSpec) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *NodeSpec) GetNodeType() isNodeSpec_NodeType {
	if x != nil {
		return x.NodeType
	}
	return nil
}

func (x *NodeSpec) GetAvfilterGraph() *AVFilterGraphSpec {
	if x != nil {
		if x, ok := x.NodeType.(*NodeSpec_AvfilterGraph); ok {
			return x.AvfilterGraph
		}
	}
	return nil
}

type isNodeSpec_NodeType interface {
	isNodeSpec_NodeType()
}

type NodeSpec_AvfilterGraph struct {
	AvfilterGraph *AVFilterGraphSpec `protobuf:"bytes,2,opt,name=avfilter_graph,json=avfilterGraph,proto3,oneof"`
}

func (*NodeSpec_AvfilterGraph) isNodeSpec_NodeType() {}

type AVFilterGraphSpec struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Description   string                 `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	Sources       []string               `protobuf:"bytes,2,rep,name=sources,proto3" json:"sources,omitempty"`
	Sinks         []string               `protobuf:"bytes,3,rep,name=sinks,proto3" json:"sinks,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AVFilterGraphSpec) Reset() {
	*x = AVFilterGraphSpec{}
	mi := &file_avf_v1_spec_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AVFilterGraphSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AVFilterGraphSpec) ProtoMessage() {}

func (x *AVFilterGraphSpec) ProtoReflect() protoreflect.Message {
	mi := &file_avf_v1_spec_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AVFilterGraphSpec.ProtoReflect.Descriptor instead.
func (*AVFilterGraphSpec) Descriptor() ([]byte, []int) {
	return file_avf_v1_spec_proto_rawDescGZIP(), []int{4}
}

func (x *AVFilterGraphSpec) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *AVFilterGraphSpec) GetSources() []string {
	if x != nil {
		return x.Sources
	}
	return nil
}

func (x *AVFilterGraphSpec) GetSinks() []string {
	if x != nil {
		return x.Sinks
	}
	return nil
}

type CodecSpec struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Type          CodecType              `protobuf:"varint,1,opt,name=type,proto3,enum=avf.v1.CodecType" json:"type,omitempty"`
	CustomType    string                 `protobuf:"bytes,16,opt,name=custom_type,json=customType,proto3" json:"custom_type,omitempty"`
	Options       map[string]string      `protobuf:"bytes,2,rep,name=options,proto3" json:"options,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CodecSpec) Reset() {
	*x = CodecSpec{}
	mi := &file_avf_v1_spec_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CodecSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CodecSpec) ProtoMessage() {}

func (x *CodecSpec) ProtoReflect() protoreflect.Message {
	mi := &file_avf_v1_spec_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CodecSpec.ProtoReflect.Descriptor instead.
func (*CodecSpec) Descriptor() ([]byte, []int) {
	return file_avf_v1_spec_proto_rawDescGZIP(), []int{5}
}

func (x *CodecSpec) GetType() CodecType {
	if x != nil {
		return x.Type
	}
	return CodecType_CODEC_TYPE_UNSPECIFIED
}

func (x *CodecSpec) GetCustomType() string {
	if x != nil {
		return x.CustomType
	}
	return ""
}

func (x *CodecSpec) GetOptions() map[string]string {
	if x != nil {
		return x.Options
	}
	return nil
}

type BitstreamFilterSpec struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Options       map[string]string      `protobuf:"bytes,2,rep,name=options,proto3" json:"options,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BitstreamFilterSpec) Reset() {
	*x = BitstreamFilterSpec{}
	mi := &file_avf_v1_spec_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BitstreamFilterSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BitstreamFilterSpec) ProtoMessage() {}

func (x *BitstreamFilterSpec) ProtoReflect() protoreflect.Message {
	mi := &file_avf_v1_spec_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BitstreamFilterSpec.ProtoReflect.Descriptor instead.
func (*BitstreamFilterSpec) Descriptor() ([]byte, []int) {
	return file_avf_v1_spec_proto_rawDescGZIP(), []int{6}
}

func (x *BitstreamFilterSpec) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *BitstreamFilterSpec) GetOptions() map[string]string {
	if x != nil {
		return x.Options
	}
	return nil
}

type TrackSpec struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	Type             TrackType              `protobuf:"varint,1,opt,name=type,proto3,enum=avf.v1.TrackType" json:"type,omitempty"`
	Codec            *CodecSpec             `protobuf:"bytes,2,opt,name=codec,proto3" json:"codec,omitempty"`
	Metadata         map[string]string      `protobuf:"bytes,3,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	BitstreamFilters []*BitstreamFilterSpec `protobuf:"bytes,4,rep,name=bitstream_filters,json=bitstreamFilters,proto3" json:"bitstream_filters,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *TrackSpec) Reset() {
	*x = TrackSpec{}
	mi := &file_avf_v1_spec_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TrackSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TrackSpec) ProtoMessage() {}

func (x *TrackSpec) ProtoReflect() protoreflect.Message {
	mi := &file_avf_v1_spec_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TrackSpec.ProtoReflect.Descriptor instead.
func (*TrackSpec) Descriptor() ([]byte, []int) {
	return file_avf_v1_spec_proto_rawDescGZIP(), []int{7}
}

func (x *TrackSpec) GetType() TrackType {
	if x != nil {
		return x.Type
	}
	return TrackType_TRACK_TYPE_UNSPECIFIED
}

func (x *TrackSpec) GetCodec() *CodecSpec {
	if x != nil {
		return x.Codec
	}
	return nil
}

func (x *TrackSpec) GetMetadata() map[string]string {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *TrackSpec) GetBitstreamFilters() []*BitstreamFilterSpec {
	if x != nil {
		return x.BitstreamFilters
	}
	return nil
}

type FormatSpec struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Type          FormatType             `protobuf:"varint,1,opt,name=type,proto3,enum=avf.v1.FormatType" json:"type,omitempty"`
	CustomType    string                 `protobuf:"bytes,16,opt,name=custom_type,json=customType,proto3" json:"custom_type,omitempty"`
	Options       map[string]string      `protobuf:"bytes,2,rep,name=options,proto3" json:"options,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Metadata      map[string]string      `protobuf:"bytes,3,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Tracks        []*TrackSpec           `protobuf:"bytes,4,rep,name=tracks,proto3" json:"tracks,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FormatSpec) Reset() {
	*x = FormatSpec{}
	mi := &file_avf_v1_spec_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FormatSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FormatSpec) ProtoMessage() {}

func (x *FormatSpec) ProtoReflect() protoreflect.Message {
	mi := &file_avf_v1_spec_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FormatSpec.ProtoReflect.Descriptor instead.
func (*FormatSpec) Descriptor() ([]byte, []int) {
	return file_avf_v1_spec_proto_rawDescGZIP(), []int{8}
}

func (x *FormatSpec) GetType() FormatType {
	if x != nil {
		return x.Type
	}
	return FormatType_FORMAT_TYPE_UNSPECIFIED
}

func (x *FormatSpec) GetCustomType() string {
	if x != nil {
		return x.CustomType
	}
	return ""
}

func (x *FormatSpec) GetOptions() map[string]string {
	if x != nil {
		return x.Options
	}
	return nil
}

func (x *FormatSpec) GetMetadata() map[string]string {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *FormatSpec) GetTracks() []*TrackSpec {
	if x != nil {
		return x.Tracks
	}
	return nil
}

type StreamSourceSpec struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamSourceSpec) Reset() {
	*x = StreamSourceSpec{}
	mi := &file_avf_v1_spec_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamSourceSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamSourceSpec) ProtoMessage() {}

func (x *StreamSourceSpec) ProtoReflect() protoreflect.Message {
	mi := &file_avf_v1_spec_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamSourceSpec.ProtoReflect.Descriptor instead.
func (*StreamSourceSpec) Descriptor() ([]byte, []int) {
	return file_avf_v1_spec_proto_rawDescGZIP(), []int{9}
}

type StreamSinkSpec struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamSinkSpec) Reset() {
	*x = StreamSinkSpec{}
	mi := &file_avf_v1_spec_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamSinkSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamSinkSpec) ProtoMessage() {}

func (x *StreamSinkSpec) ProtoReflect() protoreflect.Message {
	mi := &file_avf_v1_spec_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamSinkSpec.ProtoReflect.Descriptor instead.
func (*StreamSinkSpec) Descriptor() ([]byte, []int) {
	return file_avf_v1_spec_proto_rawDescGZIP(), []int{10}
}

type InputSpec struct {
	state  protoimpl.MessageState `protogen:"open.v1"`
	Name   string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Format *FormatSpec            `protobuf:"bytes,2,opt,name=format,proto3" json:"format,omitempty"`
	// Types that are valid to be assigned to InputType:
	//
	//	*InputSpec_Stream
	InputType isInputSpec_InputType `protobuf_oneof:"input_type"`
	// apply before the main pipeline
	// will flush when stream resets
	Pipeline      *PipelineSpec `protobuf:"bytes,4,opt,name=pipeline,proto3" json:"pipeline,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *InputSpec) Reset() {
	*x = InputSpec{}
	mi := &file_avf_v1_spec_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InputSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InputSpec) ProtoMessage() {}

func (x *InputSpec) ProtoReflect() protoreflect.Message {
	mi := &file_avf_v1_spec_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InputSpec.ProtoReflect.Descriptor instead.
func (*InputSpec) Descriptor() ([]byte, []int) {
	return file_avf_v1_spec_proto_rawDescGZIP(), []int{11}
}

func (x *InputSpec) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *InputSpec) GetFormat() *FormatSpec {
	if x != nil {
		return x.Format
	}
	return nil
}

func (x *InputSpec) GetInputType() isInputSpec_InputType {
	if x != nil {
		return x.InputType
	}
	return nil
}

func (x *InputSpec) GetStream() *StreamSourceSpec {
	if x != nil {
		if x, ok := x.InputType.(*InputSpec_Stream); ok {
			return x.Stream
		}
	}
	return nil
}

func (x *InputSpec) GetPipeline() *PipelineSpec {
	if x != nil {
		return x.Pipeline
	}
	return nil
}

type isInputSpec_InputType interface {
	isInputSpec_InputType()
}

type InputSpec_Stream struct {
	Stream *StreamSourceSpec `protobuf:"bytes,3,opt,name=stream,proto3,oneof"`
}

func (*InputSpec_Stream) isInputSpec_InputType() {}

type OutputSpec struct {
	state  protoimpl.MessageState `protogen:"open.v1"`
	Name   string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Format *FormatSpec            `protobuf:"bytes,2,opt,name=format,proto3" json:"format,omitempty"`
	// Types that are valid to be assigned to OutputType:
	//
	//	*OutputSpec_Stream
	OutputType    isOutputSpec_OutputType `protobuf_oneof:"output_type"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OutputSpec) Reset() {
	*x = OutputSpec{}
	mi := &file_avf_v1_spec_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OutputSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OutputSpec) ProtoMessage() {}

func (x *OutputSpec) ProtoReflect() protoreflect.Message {
	mi := &file_avf_v1_spec_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OutputSpec.ProtoReflect.Descriptor instead.
func (*OutputSpec) Descriptor() ([]byte, []int) {
	return file_avf_v1_spec_proto_rawDescGZIP(), []int{12}
}

func (x *OutputSpec) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *OutputSpec) GetFormat() *FormatSpec {
	if x != nil {
		return x.Format
	}
	return nil
}

func (x *OutputSpec) GetOutputType() isOutputSpec_OutputType {
	if x != nil {
		return x.OutputType
	}
	return nil
}

func (x *OutputSpec) GetStream() *StreamSinkSpec {
	if x != nil {
		if x, ok := x.OutputType.(*OutputSpec_Stream); ok {
			return x.Stream
		}
	}
	return nil
}

type isOutputSpec_OutputType interface {
	isOutputSpec_OutputType()
}

type OutputSpec_Stream struct {
	Stream *StreamSinkSpec `protobuf:"bytes,3,opt,name=stream,proto3,oneof"`
}

func (*OutputSpec_Stream) isOutputSpec_OutputType() {}

var File_avf_v1_spec_proto protoreflect.FileDescriptor

const file_avf_v1_spec_proto_rawDesc = "" +
	"\n" +
	"\x11avf/v1/spec.proto\x12\x06avf.v1\"\x9a\x01\n" +
	"\rTransformSpec\x12)\n" +
	"\x06inputs\x18\x01 \x03(\v2\x11.avf.v1.InputSpecR\x06inputs\x12,\n" +
	"\aoutputs\x18\x02 \x03(\v2\x12.avf.v1.OutputSpecR\aoutputs\x120\n" +
	"\bpipeline\x18\x03 \x01(\v2\x14.avf.v1.PipelineSpecR\bpipeline\"b\n" +
	"\fPipelineSpec\x12&\n" +
	"\x05nodes\x18\x01 \x03(\v2\x10.avf.v1.NodeSpecR\x05nodes\x12*\n" +
	"\x05links\x18\x02 \x03(\v2\x14.avf.v1.PortLinkSpecR\x05links\"x\n" +
	"\fPortLinkSpec\x12\x16\n" +
	"\x06source\x18\x01 \x01(\tR\x06source\x12\x1f\n" +
	"\vsource_port\x18\x02 \x01(\x05R\n" +
	"sourcePort\x12\x12\n" +
	"\x04sink\x18\x03 \x01(\tR\x04sink\x12\x1b\n" +
	"\tsink_port\x18\x04 \x01(\x05R\bsinkPort\"o\n" +
	"\bNodeSpec\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12B\n" +
	"\x0eavfilter_graph\x18\x02 \x01(\v2\x19.avf.v1.AVFilterGraphSpecH\x00R\ravfilterGraphB\v\n" +
	"\tnode_type\"e\n" +
	"\x11AVFilterGraphSpec\x12 \n" +
	"\vdescription\x18\x01 \x01(\tR\vdescription\x12\x18\n" +
	"\asources\x18\x02 \x03(\tR\asources\x12\x14\n" +
	"\x05sinks\x18\x03 \x03(\tR\x05sinks\"\xc9\x01\n" +
	"\tCodecSpec\x12%\n" +
	"\x04type\x18\x01 \x01(\x0e2\x11.avf.v1.CodecTypeR\x04type\x12\x1f\n" +
	"\vcustom_type\x18\x10 \x01(\tR\n" +
	"customType\x128\n" +
	"\aoptions\x18\x02 \x03(\v2\x1e.avf.v1.CodecSpec.OptionsEntryR\aoptions\x1a:\n" +
	"\fOptionsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xa9\x01\n" +
	"\x13BitstreamFilterSpec\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12B\n" +
	"\aoptions\x18\x02 \x03(\v2(.avf.v1.BitstreamFilterSpec.OptionsEntryR\aoptions\x1a:\n" +
	"\fOptionsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x9f\x02\n" +
	"\tTrackSpec\x12%\n" +
	"\x04type\x18\x01 \x01(\x0e2\x11.avf.v1.TrackTypeR\x04type\x12'\n" +
	"\x05codec\x18\x02 \x01(\v2\x11.avf.v1.CodecSpecR\x05codec\x12;\n" +
	"\bmetadata\x18\x03 \x03(\v2\x1f.avf.v1.TrackSpec.MetadataEntryR\bmetadata\x12H\n" +
	"\x11bitstream_filters\x18\x04 \x03(\v2\x1b.avf.v1.BitstreamFilterSpecR\x10bitstreamFilters\x1a;\n" +
	"\rMetadataEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xf2\x02\n" +
	"\n" +
	"FormatSpec\x12&\n" +
	"\x04type\x18\x01 \x01(\x0e2\x12.avf.v1.FormatTypeR\x04type\x12\x1f\n" +
	"\vcustom_type\x18\x10 \x01(\tR\n" +
	"customType\x129\n" +
	"\aoptions\x18\x02 \x03(\v2\x1f.avf.v1.FormatSpec.OptionsEntryR\aoptions\x12<\n" +
	"\bmetadata\x18\x03 \x03(\v2 .avf.v1.FormatSpec.MetadataEntryR\bmetadata\x12)\n" +
	"\x06tracks\x18\x04 \x03(\v2\x11.avf.v1.TrackSpecR\x06tracks\x1a:\n" +
	"\fOptionsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\x1a;\n" +
	"\rMetadataEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x12\n" +
	"\x10StreamSourceSpec\"\x10\n" +
	"\x0eStreamSinkSpec\"\xbf\x01\n" +
	"\tInputSpec\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12*\n" +
	"\x06format\x18\x02 \x01(\v2\x12.avf.v1.FormatSpecR\x06format\x122\n" +
	"\x06stream\x18\x03 \x01(\v2\x18.avf.v1.StreamSourceSpecH\x00R\x06stream\x120\n" +
	"\bpipeline\x18\x04 \x01(\v2\x14.avf.v1.PipelineSpecR\bpipelineB\f\n" +
	"\n" +
	"input_type\"\x8d\x01\n" +
	"\n" +
	"OutputSpec\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12*\n" +
	"\x06format\x18\x02 \x01(\v2\x12.avf.v1.FormatSpecR\x06format\x120\n" +
	"\x06stream\x18\x03 \x01(\v2\x16.avf.v1.StreamSinkSpecH\x00R\x06streamB\r\n" +
	"\voutput_type*S\n" +
	"\tTrackType\x12\x1a\n" +
	"\x16TRACK_TYPE_UNSPECIFIED\x10\x00\x12\x14\n" +
	"\x10TRACK_TYPE_AUDIO\x10\x01\x12\x14\n" +
	"\x10TRACK_TYPE_VIDEO\x10\x02*S\n" +
	"\tCodecType\x12\x1a\n" +
	"\x16CODEC_TYPE_UNSPECIFIED\x10\x00\x12\x15\n" +
	"\x11CODEC_TYPE_CUSTOM\x10\x10\x12\x13\n" +
	"\x0fCODEC_TYPE_NONE\x10\x01*V\n" +
	"\n" +
	"FormatType\x12\x1b\n" +
	"\x17FORMAT_TYPE_UNSPECIFIED\x10\x00\x12\x16\n" +
	"\x12FORMAT_TYPE_CUSTOM\x10\x10\x12\x13\n" +
	"\x0fFORMAT_TYPE_RAW\x10\x01B\x86\x01\n" +
	"\n" +
	"com.avf.v1B\tSpecProtoP\x01Z4github.com/brian14708/gst-server/sdk/go/avf/v1;avfv1\xa2\x02\x03AXX\xaa\x02\x06Avf.V1\xca\x02\x06Avf\\V1\xe2\x02\x12Avf\\V1\\GPBMetadata\xea\x02\aAvf::V1b\x06proto3"

var (
	file_avf_v1_spec_proto_rawDescOnce sync.Once
	file_avf_v1_spec_proto_rawDescData []byte
)

func file_avf_v1_spec_proto_rawDescGZIP() []byte {
	file_avf_v1_spec_proto_rawDescOnce.Do(func() {
		file_avf_v1_spec_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_avf_v1_spec_proto_rawDesc), len(file_avf_v1_spec_proto_rawDesc)))
	})
	return file_avf_v1_spec_proto_rawDescData
}

var (
	file_avf_v1_spec_proto_enumTypes = make([]protoimpl.EnumInfo, 3)
	file_avf_v1_spec_proto_msgTypes  = make([]protoimpl.MessageInfo, 18)
	file_avf_v1_spec_proto_goTypes   = []any{
		(TrackType)(0),              // 0: avf.v1.TrackType
		(CodecType)(0),              // 1: avf.v1.CodecType
		(FormatType)(0),             // 2: avf.v1.FormatType
		(*TransformSpec)(nil),       // 3: avf.v1.TransformSpec
		(*PipelineSpec)(nil),        // 4: avf.v1.PipelineSpec
		(*PortLinkSpec)(nil),        // 5: avf.v1.PortLinkSpec
		(*NodeSpec)(nil),            // 6: avf.v1.NodeSpec
		(*AVFilterGraphSpec)(nil),   // 7: avf.v1.AVFilterGraphSpec
		(*CodecSpec)(nil),           // 8: avf.v1.CodecSpec
		(*BitstreamFilterSpec)(nil), // 9: avf.v1.BitstreamFilterSpec
		(*TrackSpec)(nil),           // 10: avf.v1.TrackSpec
		(*FormatSpec)(nil),          // 11: avf.v1.FormatSpec
		(*StreamSourceSpec)(nil),    // 12: avf.v1.StreamSourceSpec
		(*StreamSinkSpec)(nil),      // 13: avf.v1.StreamSinkSpec
		(*InputSpec)(nil),           // 14: avf.v1.InputSpec
		(*OutputSpec)(nil),          // 15: avf.v1.OutputSpec
		nil,                         // 16: avf.v1.CodecSpec.OptionsEntry
		nil,                         // 17: avf.v1.BitstreamFilterSpec.OptionsEntry
		nil,                         // 18: avf.v1.TrackSpec.MetadataEntry
		nil,                         // 19: avf.v1.FormatSpec.OptionsEntry
		nil,                         // 20: avf.v1.FormatSpec.MetadataEntry
	}
)

var file_avf_v1_spec_proto_depIdxs = []int32{
	14, // 0: avf.v1.TransformSpec.inputs:type_name -> avf.v1.InputSpec
	15, // 1: avf.v1.TransformSpec.outputs:type_name -> avf.v1.OutputSpec
	4,  // 2: avf.v1.TransformSpec.pipeline:type_name -> avf.v1.PipelineSpec
	6,  // 3: avf.v1.PipelineSpec.nodes:type_name -> avf.v1.NodeSpec
	5,  // 4: avf.v1.PipelineSpec.links:type_name -> avf.v1.PortLinkSpec
	7,  // 5: avf.v1.NodeSpec.avfilter_graph:type_name -> avf.v1.AVFilterGraphSpec
	1,  // 6: avf.v1.CodecSpec.type:type_name -> avf.v1.CodecType
	16, // 7: avf.v1.CodecSpec.options:type_name -> avf.v1.CodecSpec.OptionsEntry
	17, // 8: avf.v1.BitstreamFilterSpec.options:type_name -> avf.v1.BitstreamFilterSpec.OptionsEntry
	0,  // 9: avf.v1.TrackSpec.type:type_name -> avf.v1.TrackType
	8,  // 10: avf.v1.TrackSpec.codec:type_name -> avf.v1.CodecSpec
	18, // 11: avf.v1.TrackSpec.metadata:type_name -> avf.v1.TrackSpec.MetadataEntry
	9,  // 12: avf.v1.TrackSpec.bitstream_filters:type_name -> avf.v1.BitstreamFilterSpec
	2,  // 13: avf.v1.FormatSpec.type:type_name -> avf.v1.FormatType
	19, // 14: avf.v1.FormatSpec.options:type_name -> avf.v1.FormatSpec.OptionsEntry
	20, // 15: avf.v1.FormatSpec.metadata:type_name -> avf.v1.FormatSpec.MetadataEntry
	10, // 16: avf.v1.FormatSpec.tracks:type_name -> avf.v1.TrackSpec
	11, // 17: avf.v1.InputSpec.format:type_name -> avf.v1.FormatSpec
	12, // 18: avf.v1.InputSpec.stream:type_name -> avf.v1.StreamSourceSpec
	4,  // 19: avf.v1.InputSpec.pipeline:type_name -> avf.v1.PipelineSpec
	11, // 20: avf.v1.OutputSpec.format:type_name -> avf.v1.FormatSpec
	13, // 21: avf.v1.OutputSpec.stream:type_name -> avf.v1.StreamSinkSpec
	22, // [22:22] is the sub-list for method output_type
	22, // [22:22] is the sub-list for method input_type
	22, // [22:22] is the sub-list for extension type_name
	22, // [22:22] is the sub-list for extension extendee
	0,  // [0:22] is the sub-list for field type_name
}

func init() { file_avf_v1_spec_proto_init() }
func file_avf_v1_spec_proto_init() {
	if File_avf_v1_spec_proto != nil {
		return
	}
	file_avf_v1_spec_proto_msgTypes[3].OneofWrappers = []any{
		(*NodeSpec_AvfilterGraph)(nil),
	}
	file_avf_v1_spec_proto_msgTypes[11].OneofWrappers = []any{
		(*InputSpec_Stream)(nil),
	}
	file_avf_v1_spec_proto_msgTypes[12].OneofWrappers = []any{
		(*OutputSpec_Stream)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_avf_v1_spec_proto_rawDesc), len(file_avf_v1_spec_proto_rawDesc)),
			NumEnums:      3,
			NumMessages:   18,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_avf_v1_spec_proto_goTypes,
		DependencyIndexes: file_avf_v1_spec_proto_depIdxs,
		EnumInfos:         file_avf_v1_spec_proto_enumTypes,
		MessageInfos:      file_avf_v1_spec_proto_msgTypes,
	}.Build()
	File_avf_v1_spec_proto = out.File
	file_avf_v1_spec_proto_goTypes = nil
	file_avf_v1_spec_proto_depIdxs = nil
}
